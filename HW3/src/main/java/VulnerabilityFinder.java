import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.Language;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.NormalStatement;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer;
import com.ibm.wala.ipa.slicer.Statement;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.types.*;
import com.ibm.wala.util.config.AnalysisScopeReader;
import com.ibm.wala.util.io.FileProvider;
import com.ibm.wala.util.strings.Atom;
import com.ibm.wala.viz.viewer.WalaViewer;

import java.io.File;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static com.ibm.wala.types.TypeReference.findOrCreate;

public class VulnerabilityFinder {


    public static void main(String[] args) throws Exception {
        File exFile = new FileProvider().getFile("Java60RegressionExclusions.txt");

        URL resource = LiveExampleL15.class.getResource("Sample.jar");
        AnalysisScope scope = AnalysisScopeReader.makeJavaBinaryAnalysisScope(resource.getPath(), exFile);
        String runtimeClasses = LiveExampleL15.class.getResource("jdk-17.0.1/rt.jar").getPath();
        AnalysisScopeReader.addClassPathToScope(runtimeClasses, scope, ClassLoaderReference.Primordial);

        IClassHierarchy classHierarchy = ClassHierarchyFactory.make(scope);

        // DEMO: n-CFA
        AnalysisOptions options = new AnalysisOptions();
        options.setEntrypoints(Util.makeMainEntrypoints(scope, classHierarchy));
        SSAPropagationCallGraphBuilder builder = Util.makeZeroOneCFABuilder(Language.JAVA,options,new AnalysisCacheImpl(), classHierarchy, scope);//Util.makeNCFABuilder(1, options, new AnalysisCacheImpl(), classHierarchy, scope);
        CallGraph callGraph = builder.makeCallGraph(options);

        System.out.println("# Nodes " + callGraph.getNumberOfNodes());
        PointerAnalysis<InstanceKey> pa = builder.getPointerAnalysis();
        SDG<InstanceKey> sdg = new SDG(callGraph, pa, Slicer.DataDependenceOptions.NO_BASE_NO_HEAP_NO_EXCEPTIONS, Slicer.ControlDependenceOptions.FULL);

        System.out.println(sdg.getNumberOfNodes());

        new WalaViewer(callGraph, builder.getPointerAnalysis());


        List<Statement> sinks = findSinks(sdg);
        for (Statement sink : sinks) {
            System.out.println(sink);
        }

    }


    public static final TypeReference JavaLangRuntime =
            findOrCreate(ClassLoaderReference.Application, TypeName.string2TypeName("Ljava/lang/Runtime"));

    public static final MethodReference sinkReference =
            MethodReference.findOrCreate(JavaLangRuntime,
                    Atom.findOrCreateUnicodeAtom("exec"),
                    Descriptor.findOrCreateUTF8("(Ljava/lang/String;)Ljava/lang/Process;"));


    public static List<Statement> findSinks(SDG<InstanceKey> sdg) {
        List<Statement> result = new ArrayList<>();
        for (Statement s : sdg) {
            if (s.getKind().equals(Statement.Kind.NORMAL) && isApplicationScope(s)) {
                SSAInstruction instruction = ((NormalStatement) s).getInstruction();
                if (instruction instanceof SSAAbstractInvokeInstruction) {
//                    System.out.println(instruction);
                    if (((SSAAbstractInvokeInstruction) instruction).getDeclaredTarget().equals(sinkReference))
                        result.add(s);
                }
            }
        }
        return result;
    }

    /**
     * True if the IClass is under the application-scope ({@code ClassLoaderReference.Application}).
     *
     * @param iClass
     * @return
     */
    public static boolean isApplicationScope(IClass iClass) {
        return iClass != null && iClass.getClassLoader().getReference().equals(ClassLoaderReference.Application);
    }

    /**
     * True if the CGNode is under the application-scope ({@code ClassLoaderReference.Application}).
     *
     * @param node call graph node.
     * @return true if the node is declared in the application.
     */
    public static boolean isApplicationScope(CGNode node) {
        return node.getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Application);
    }

    /**
     * True if the statement is under the application-scope.
     *
     * @param s
     * @return
     */
    public static boolean isApplicationScope(Statement s) {
        return s.getNode().getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Application);
    }

    /**
     * True if the statement is under Java-scope (primordial)
     *
     * @param s
     * @return
     */
    public static boolean isPrimordialScope(Statement s) {
        return s.getNode().getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Primordial);
    }

    /**
     * True if the class is under Java-scope (primordial)
     *
     * @param c
     * @return
     */
    public static boolean isPrimordialScope(IClass c) {
        return c.getClassLoader().getReference().equals(ClassLoaderReference.Primordial);
    }

    /**
     * True if the call graph node is under Java-scope (primordial)
     *
     * @param cgNode
     * @return
     */
    public static boolean isPrimordialScope(CGNode cgNode) {
        return cgNode.getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Primordial);
    }


}
